[{"id":"451ee4a035442e0633cafdb9c68dc333","title":"数据库优化第一步看懂explain","content":"explain常用字段\n\n\n\n\n\n\n\n\n\ntype ：访问的类型\nkey ：实际使用到的索引，如果为NULL，则没有使用索引\nref ：显示索引的哪一列被使用了，如果可能的话，是一个常数，哪些列或常量被用于查找索引列上的值\nrows ：根据表统计信息及索引选用情况，大致估算出找到所需的记录所需读取的行数\nExtra ：包含不适合在其它列中显示但十分重要的额外信息\n\n表数据sqlCREATE TABLE `user` (\n  `id` int NOT NULL AUTO_INCREMENT,\n  `name` varchar(255) CHARACTER SET armscii8 COLLATE armscii8_general_ci NOT NULL,\n  `account` varchar(255) CHARACTER SET armscii8 COLLATE armscii8_general_ci NOT NULL,\n  `pass` varchar(255) CHARACTER SET armscii8 COLLATE armscii8_general_ci NOT NULL,\n  `email` varchar(255) CHARACTER SET armscii8 COLLATE armscii8_general_ci NULL DEFAULT NULL,\n  PRIMARY KEY (`id`) USING BTREE\n) ENGINE = InnoDB CHARACTER SET = armscii8 COLLATE = armscii8_general_ci ROW_FORMAT = Dynamic;\n\nINSERT INTO `test`.`user` (`id`, `name`, `account`, `pass`, `email`) VALUES (1, &#39;User1&#39;, &#39;user1&#39;, &#39;pass1&#39;, &#39;user1@example.com&#39;);\n。。。常用分析sqlEXPLAIN select * from user where id = 14\n+----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+\n| id | select_type | table | partitions | type  | possible_keys | key     | key_len | ref   | rows | filtered | Extra |\n+----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+\n|  1 | SIMPLE      | user  | NULL       | const | PRIMARY       | PRIMARY | 4       | const |    1 |   100.00 | NULL  |\n+----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+\n1 row in set, 1 warning (0.00 sec)\n\n\n\n\n\n\n\n\nkey: PRIMARY 走的主键索引\nref： const 判断条件为常数匹配\nrows： 1  扫描数据条数\n范围匹配\nsqlEXPLAIN select * from user where id &gt;= 10 and id &lt;= 50;\n+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+-------------+\n| id | select_type | table | partitions | type  | possible_keys | key     | key_len | ref  | rows | filtered | Extra       |\n+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+-------------+\n|  1 | SIMPLE      | user  | NULL       | range | PRIMARY       | PRIMARY | 4       | NULL |   41 |   100.00 | Using where |\n+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+-------------+\n1 row in set, 1 warning (0.00 sec)\n\n\n\n\n\n\n\n\nkey: PRIMARY 主键索引\ntype： range 区间扫描\nrows: 41 扫描行数\nExtra： Using where 使用了where条件\n唯一约束\nsql-- 将account字段设置为唯一约束\nALTER TABLE user ADD CONSTRAINT UNIQUE(account);\nmysql&gt; EXPLAIN select * from user where account like &#39;user%&#39;；\n+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+-----------------------+\n| id | select_type | table | partitions | type  | possible_keys | key     | key_len | ref  | rows | filtered | Extra                 |\n+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+-----------------------+\n|  1 | SIMPLE      | user  | NULL       | range | account       | account | 257     | NULL |   51 |   100.00 | Using index condition |\n+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+-----------------------+\n1 row in set, 1 warning (0.00 sec)\n\n\n\n\n\n\n\n\nkey: account account字段索引\nrow: 51扫描行数\nExtra： Using index condition 使用索引判断\nsqlmysql&gt; EXPLAIN select * from user where account like &#39;%user&#39;;\n+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+\n| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |\n+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+\n|  1 | SIMPLE      | user  | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 1051 |    11.11 | Using where |\n+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+\n1 row in set, 1 warning (0.00 sec)\n\n\n\n\n\n\n\n\ntype: ALL 全表扫描 常见的索引失效\nsqlmysql&gt; EXPLAIN select * from user where id &gt;= 5 and id &lt;= 10 order by account;\n+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+-----------------------------+\n| id | select_type | table | partitions | type  | possible_keys | key     | key_len | ref  | rows | filtered | Extra                       |\n+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+-----------------------------+\n|  1 | SIMPLE      | user  | NULL       | range | PRIMARY       | PRIMARY | 4       | NULL |    6 |   100.00 | Using where; Using filesort |\n+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+-----------------------------+\n1 row in set, 1 warning (0.00 sec)\n\n\n\n\n\n\n\n\nExtra: Using where; Using filesort 使用条件判断，将判断出的数据进行文件排序（通常是以为没走索引所以才需要排序）\nsqlmysql&gt; explain select count(*) from user group by pass;\n+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-----------------+\n| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra           |\n+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-----------------+\n|  1 | SIMPLE      | user  | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 1051 |   100.00 | Using temporary |\n+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-----------------+\n1 row in set, 1 warning (0.00 sec)\n\nmysql&gt; explain select count(*) from user group by id;\n+----+-------------+-------+------------+-------+-----------------+---------+---------+------+------+----------+-------------+\n| id | select_type | table | partitions | type  | possible_keys   | key     | key_len | ref  | rows | filtered | Extra       |\n+----+-------------+-------+------------+-------+-----------------+---------+---------+------+------+----------+-------------+\n|  1 | SIMPLE      | user  | NULL       | index | PRIMARY,account | PRIMARY | 4       | NULL | 1051 |   100.00 | Using index |\n+----+-------------+-------+------------+-------+-----------------+---------+---------+------+------+----------+-------------+\n1 row in set, 1 warning (0.00 sec)\n\n\n\n\n\n\n\n\nExtra : Using temporary 表示Mysql创建了临时表来查询存储结果，通用在排序或分组发生\nsqlmysql&gt; explain select count(*) from user where id in( 100,123,112,121);\n+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+--------------------------+\n| id | select_type | table | partitions | type  | possible_keys | key     | key_len | ref  | rows | filtered | Extra                    |\n+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+--------------------------+\n|  1 | SIMPLE      | user  | NULL       | range | PRIMARY       | PRIMARY | 4       | NULL |    4 |   100.00 | Using where; Using index |\n+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+--------------------------+\n1 row in set, 1 warning (0.00 sec)\n\nmysql&gt; explain select count(*) from user where name in( user1,user3,user20,user40);\nERROR 1054 (42S22): Unknown column &#39;user1&#39; in &#39;where clause&#39;\nmysql&gt; explain select count(*) from user where name in( &#39;user1&#39;,&#39;user3&#39;,&#39;user20&#39;,&#39;user40&#39;);\n+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+\n| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |\n+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+\n|  1 | SIMPLE      | user  | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 1051 |    40.00 | Using where |\n+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+\n1 row in set, 1 warning (0.00 sec)","slug":"arary/Explain","date":"2024-05-20T04:01:51.000Z","categories_index":"mysql","tags_index":"mysql","author_index":"panther"},{"id":"62f0380213af8188cf68f0ab26ba211b","title":"Redis实战之Redisson使用技巧详解","content":"摘要什么是 Redisson？来自于官网上的描述内容如下！\n\n\n\n\n\n\n\n\n\nRedisson 是一个在 Redis 的基础上实现的 Java 驻内存数据网格客户端（In-Memory Data Grid）。它不仅提供了一系列的 redis常用数据结构命令服务，还提供了许多分布式服务，例如分布式锁、分布式对象、分布式集合、分布式远程服务、分布式调度任务服务等等。\n相比于 Jedis、Lettuce 等基于 redis 命令封装的客户端，Redisson 提供的功能更加高端和抽象，逼格高！\n更多功能特性和开发文档说明，可用移步github进行获取，访问地址如下：\nredisson地址\n基本使用跟过去一样，首先创建一个 maven 项目，添加Redisson依赖包。\nxml&lt;dependency&gt;\n  &lt;groupId&gt;org.redisson&lt;/groupId&gt;\n  &lt;artifactId&gt;redisson&lt;/artifactId&gt;\n  &lt;version&gt;3.13.6&lt;/version&gt;\n&lt;/dependency&gt;单机环境下，简单样例如下！\njavapublic static void main(String[] args) &#123;\n        Config config = new Config();\n        config.useSingleServer()\n                .setConnectionMinimumIdleSize(5) // 设置最下空闲数\n                .setConnectionPoolSize(10) // 设置连接池大小\n                .setIdleConnectionTimeout(3*1000) // 设置空闲连接超时时间 单位为毫秒\n                .setConnectTimeout(10*1000) // 设置连接超时时间 单位为毫秒\n                .setAddress(&quot;redis://127.0.0.1:6379&quot;)\n                .setDatabase(0);\n        //获取客户端\n        RedissonClient redissonClient = Redisson.create(config);\n        RBucket&lt;String&gt; selfBucket = redissonClient.getBucket(&quot;selfBucket&quot;);\n        selfBucket.set(&quot;hello&quot;,3, TimeUnit.SECONDS);\n        selfBucket.set(&quot;world&quot;);\n        //获取所有的key\n        redissonClient.getKeys().getKeys().forEach(key -&gt; System.out.println(key));\n        //关闭客户端\n        redissonClient.shutdown();\n    &#125;\n\n\n\n\n\n\n\n\nps：创建 RedissonClient 对象实例的方式多钟多样，可以直接通过在代码中设置 Redis 服务的相关参数创建，也可以通过加载 JSON 格式、 YAML 格式或者 Spring XML 配置文件来创建，详细的参数配置可用移步上文提到的 Redisson 开发文档。\nStringRedisson 支持通过RBucket对象来操作字符串数据结构，通过RBucket实例可以设置value或设置value和有效期，简单样例如下！\n\n简单字符串操作\n\njava//字符串操作\nRBucket&lt;String&gt; rBucket = redissonClient.getBucket(&quot;strKey&quot;);\n// 设置value和key的有效期\nrBucket.set(&quot;张三&quot;, 30, TimeUnit.SECONDS);\n//rBucket.getAndDelete();  获取strKey的值并删除strKey这个key\n//rBucket.compareAndSet(&quot;张三&quot;,&quot;李四&quot;); 和cas想同先比较后设置\n//rBucket.setIfExists(&quot;hello1&quot;); 存在值就设置\n// 通过key获取value\n//rBucket.isExists(); 判断当前桶是否有值\n// rBucket.delete(); 删除桶中数据\nSystem.out.println(redissonClient.getBucket(&quot;strKey&quot;).get());\n对象操作\n\nRedisson 支持将对象作为value存入redis，被存储的对象事先必须要实现序列化接口Serializable，否则会报错，简单样例如下！\njava//字符串对象操作\nRBucket&lt;user&gt; rBucket = redissonClient.getBucket(&quot;strKey2&quot;);\nrBucket.set(new user().setId(1001).setName(&quot;stone&quot;));\nSystem.out.println(redissonClient.getBucket(&quot;strKey2&quot;).get());hashRedisson 支持通过RMap对象来操作哈希数据结构，简单样例如下！\njavaRMap&lt;String, String&gt; rMap = redissonClient.getMap(&quot;mapkey&quot;);\nrMap.put(&quot;id&quot;, &quot;123&quot;);\nrMap.put(&quot;name&quot;, &quot;赵四&quot;);\nrMap.put(&quot;age&quot;, &quot;50&quot;);\n//rMap.putIfAbsent() 如果不存在设置\n//rMap.size() 大小\n// rMap.clear();清空集合\nrMap.expire(30, TimeUnit.SECONDS);\nSystem.out.println(redissonClient.getMap(&quot;mapkey&quot;).get(&quot;name&quot;));listjavaRList&lt;user&gt; rList = redissonClient.getList(&quot;listkey&quot;);\n\nuser student1 = new user();\nstudent1.setId(1);\nstudent1.setName(&quot;张三&quot;);\nrList.add(student1);\n\nuser student2 = new user();\nstudent2.setId(2);\nstudent2.setName(&quot;李四&quot;);\nrList.add(student2);\n\n//设置过期时间\nrList.expire(30, TimeUnit.SECONDS);\n// rList.subList(0,rList.size()).clear(); 获取子列表\n// rList.contains(student1);  判断是否存在student1\n// rList.indexOf(student2)   返回student2第一次出现的位置\n//  rList.lastIndexOf(student2)   返回student2最后一次出现的位置\n//rList.retainAll(Arrays.asList(student2)); 仅保留列表中存在的集合\n// rList.toArray() 转化成集合\n// 通过key获取value\nSystem.out.println(redissonClient.getList(&quot;listkey&quot;));setjavaRSet&lt;user&gt; rSet = redissonClient.getSet(&quot;setkey&quot;);\n\nuser student1 = new user();\nstudent1.setId(1L);\nstudent1.setName(&quot;张三&quot;);\nrSet.add(student1);\n\nuser student2 = new user();\nstudent2.setId(2L);\nstudent2.setName(&quot;李四&quot;);\nrSet.add(student2);\n\nrSet.expire(30, TimeUnit.SECONDS);\n// rSet.contains(student1);判断集合中是否包含指定的元素。\n// rSet.iterator();返回集合的迭代器\n// rSet.retainAll(Arrays.asList(student1, student2));仅保留集合中包含在指定集合中的元素，移除其他元素。\nSystem.out.println(redissonClient.getSet(&quot;setkey&quot;));zsetRedisson 支持通过RSortedSet对象来操作有序集合数据结构，在使用对象来存储之前，实体对象必须先实现Comparable接口，并重写比较逻辑，否则会报错，简单样例如下！\njavaRSortedSet&lt;user&gt; sortSetkey = redissonClient.get(&quot;sortSetkey&quot;);\n\nuser student1 = new user();\nstudent1.setId(1);\nstudent1.setName(&quot;张三&quot;);\nsortSetkey.add(student1);\n\nuser student2 = new user();\nstudent2.setId(2);\nstudent2.setName(&quot;李四&quot;);\nsortSetkey.add(student2);\n\n// sortSetkey.iterator() 返回集合的迭代器\nSystem.out.println(redissonClient.getSortedSet(&quot;sortSetkey&quot;));添加监听以String为例来对redis的一些操作进行监听\n布隆过滤器布隆过滤器（Bloom Filter）是 1970 年由布隆提出的。它实际上是一个很长的二进制向量和一系列随机映射函数。\n布隆过滤器可以用于检索一个元素是否在一个集合中。它的优点是空间效率和查询时间都比一般的算法要好的多，缺点是有一定的误识别率和删除困难。\nRedisson 支持通过RBloomFilter对象来操作布隆过滤器，简单样例如下！\njavaRBloomFilter rBloomFilter = redissonClient.getBloomFilter(&quot;seqId&quot;);\n// 初始化预期插入的数据量为10000和期望误差率为0.01\nrBloomFilter.tryInit(10000, 0.01);\n// 插入部分数据\nrBloomFilter.add(&quot;100&quot;);\nrBloomFilter.add(&quot;200&quot;);\nrBloomFilter.add(&quot;300&quot;);\n//设置过期时间\nrBloomFilter.expire(30, TimeUnit.SECONDS);\n// 判断是否存在\nSystem.out.println(rBloomFilter.contains(&quot;300&quot;));\nSystem.out.println(rBloomFilter.contains(&quot;200&quot;));\nSystem.out.println(rBloomFilter.contains(&quot;999&quot;));分布式自增idID 是数据的唯一标识，传统的做法是利用 UUID 和数据库的自增 ID。\n但由于 UUID 是无序的，不能附带一些其他信息，因此实际作用有限。\n随着业务的发展，数据量会越来越大，需要对数据进行分表，甚至分库。分表后每个表的数据会按自己的节奏来自增，这样会造成 ID 冲突，因此这时就需要一个单独的机制来负责生成唯一 ID，redis 原生支持生成全局唯一的 ID。\n简单样例如下！\njavafinal String lockKey = &quot;aaaa&quot;;\n//通过redis的自增获取序号\nRAtomicLong atomicLong = redissonClient.getAtomicLong(lockKey);\n//设置过期时间\natomicLong.expire(30, TimeUnit.SECONDS);\n// 获取值\nSystem.out.println(atomicLong.incrementAndGet());分布式锁Redisson 最大的亮点，也是使用最多的功能，就是提供了强大的分布式锁实现，特点是：使用简单、安全！\n简单使用样例如下！\njavaConfig config = new Config();\nconfig.useSingleServer()\n        .setAddress(&quot;redis://127.0.0.1:6379&quot;)\n        .setPassword(&quot;123456&quot;)\n        .setDatabase(0);\nRedissonClient redissonClient = Redisson.create(config);\n//获取锁对象实例\nfinal String lockKey = &quot;abc&quot;;\nRLock rLock = redissonClient.getLock(lockKey);\n\ntry &#123;\n    //尝试5秒内获取锁，如果获取到了，最长60秒自动释放\n    boolean res = rLock.tryLock(5L, 60L, TimeUnit.SECONDS);\n    if (res) &#123;\n        //成功获得锁，在这里处理业务\n        System.out.println(&quot;获取锁成功&quot;);\n    &#125;\n&#125; catch (Exception e) &#123;\n    System.out.println(&quot;获取锁失败，失败原因：&quot; + e.getMessage());\n&#125; finally &#123;\n    //无论如何, 最后都要解锁\n    rLock.unlock();\n&#125;\n\n//关闭客户端\nredissonClient.shutdown();以上是单机环境下的分布式锁实现逻辑，如果是集群环境下，应该如何处理呢？\nRedisson 提供RedissonRedLock操作类，也被称为红锁，实现原理简单的总结有以下几点：\n\n1.如果有多个 redis 集群的时候，当且仅当从大多数（N&#x2F;2+1，比如有3个 redis 节点，那么至少有2个节点）的 Redis 节点都取到锁，并且获取锁使用的总耗时小于锁失效时间时，锁才算获取成功\n2.如果获取失败，客户端会在所有的 Redis 实例上进行解锁操作\n3.集群环境下，redis 服务器直接不存在任何复制或者其他隐含的分布式协调机制，否则会存在实效的可能\n\nRedissonRedLock简单使用样例如下！\njavaConfig config1 = new Config();\nconfig1.useSingleServer().setAddress(&quot;redis://192.168.3.111:6379&quot;).setPassword(&quot;a123456&quot;).setDatabase(0);\nRedissonClient redissonClient1 = Redisson.create(config1);\n\nConfig config2 = new Config();\nconfig2.useSingleServer().setAddress(&quot;redis://192.168.3.112:6379&quot;).setPassword(&quot;a123456&quot;).setDatabase(0);\nRedissonClient redissonClient2 = Redisson.create(config2);\n\nConfig config3 = new Config();\nconfig3.useSingleServer().setAddress(&quot;redis://192.168.3.113:6379&quot;).setPassword(&quot;a123456&quot;).setDatabase(0);\nRedissonClient redissonClient3 = Redisson.create(config3);\n\n//获取多个 RLock 对象\nfinal String lockKey = &quot;abc&quot;;\nRLock lock1 = redissonClient1.getLock(lockKey);\nRLock lock2 = redissonClient2.getLock(lockKey);\nRLock lock3 = redissonClient3.getLock(lockKey);\n\n//根据多个 RLock 对象构建 RedissonRedLock （最核心的差别就在这里）\nRedissonRedLock redLock = new RedissonRedLock(lock1, lock2, lock3);\n\ntry &#123;\n    //尝试5秒内获取锁，如果获取到了，最长60秒自动释放\n    boolean res = redLock.tryLock(5L, 60L, TimeUnit.SECONDS);\n    if (res) &#123;\n        //成功获得锁，在这里处理业务\n        System.out.println(&quot;获取锁成功&quot;);\n\n    &#125;\n&#125; catch (Exception e) &#123;\n    System.out.println(&quot;获取锁失败，失败原因：&quot; + e.getMessage());\n&#125; finally &#123;\n    //无论如何, 最后都要解锁\n    redLock.unlock();\n&#125;集群模式javaConfig config = new Config();\nconfig.useClusterServers()\n    .setScanInterval(2000) // 集群状态扫描间隔时间，单位是毫秒\n    //可以用&quot;rediss://&quot;来启用SSL连接\n    .addNodeAddress(&quot;redis://127.0.0.1:7000&quot;, &quot;redis://127.0.0.1:7001&quot;)\n    .addNodeAddress(&quot;redis://127.0.0.1:7002&quot;);\n\nRedissonClient redisson = Redisson.create(config);主从模式javaConfig config = new Config();\nconfig.useMasterSlaveServers()\n    //可以用&quot;rediss://&quot;来启用SSL连接\n    .setMasterAddress(&quot;redis://127.0.0.1:6379&quot;)\n    .addSlaveAddress(&quot;redis://127.0.0.1:6389&quot;, &quot;redis://127.0.0.1:6332&quot;, &quot;redis://127.0.0.1:6419&quot;)\n    .addSlaveAddress(&quot;redis://127.0.0.1:6399&quot;);\n\nRedissonClient redisson = Redisson.create(config);哨兵模式javaConfig config = new Config();\nconfig.useSentinelServers()\n    .setMasterName(&quot;mymaster&quot;)\n    //可以用&quot;rediss://&quot;来启用SSL连接\n    .addSentinelAddress(&quot;127.0.0.1:26389&quot;, &quot;127.0.0.1:26379&quot;)\n    .addSentinelAddress(&quot;127.0.0.1:26319&quot;);\n\nRedissonClient redisson = Redisson.create(config);","slug":"backend/redisson","date":"2024-05-16T04:01:51.000Z","categories_index":"backend","tags_index":"redis","author_index":"panther"},{"id":"568c8981e612913b5236501ef69a4929","title":"项目实战之批量插入性能分析","content":"\n\n\n\n\n\n\n\n\n不是专业测试，时间的参考价值不大，但是常见的批量插入方法应该能帮到你。\n模拟表sqlDROP TABLE IF EXISTS emp;\nCREATE TABLE emp (\n    id INT AUTO_INCREMENT PRIMARY KEY,\n    userName VARCHAR(255),\n    pass VARCHAR(255),\n    email VARCHAR(255)\n);\n存储过程sqlDELIMITER //\n\nCREATE PROCEDURE insert_emp_data()\nBEGIN\n    DECLARE i INT DEFAULT 1;\n    DECLARE batch_size INT DEFAULT 1000;\n    DECLARE total INT DEFAULT 100000;\n    DECLARE j INT;\n\n    WHILE i &lt;= total DO\n        START TRANSACTION;\n\n        SET j = 0;\n        WHILE j &lt; batch_size AND i &lt;= total DO\n            INSERT INTO emp (userName, pass, email)\n            VALUES (CONCAT(&#39;user&#39;, i), CONCAT(&#39;pass&#39;, i), CONCAT(&#39;user&#39;, i, &#39;@example.com&#39;));\n            SET i = i + 1;\n            SET j = j + 1;\n        END WHILE;\n        COMMIT;\n    END WHILE;\nEND //\n\nDELIMITER ;\nCALL insert_emp_data();使用Mysql自带的存储过程进行10万条数据插入： \n\n\n\n\n\n\n\n\n\n耗时： 9.125 s\nMybatis-Foreach组装数据\njava@RestController\npublic class TestController &#123;\n    private static List&lt;Emp&gt;  list;\n\n    @Resource\n    private TestMapper testMapper;\n\n    static &#123;\n        list = new ArrayList&lt;&gt;(100000);\n        for (int i = 0; i &lt; 100000; i++) &#123;\n            Emp emp = new Emp();\n            emp.setUserName(&quot;user&quot;+i);\n            emp.setPass(&quot;123&quot;+i);\n            emp.setEmail(&quot;example&quot;+i);\n            list.add(emp);\n        &#125;\n    &#125;\n    @GetMapping(&quot;/foreach&quot;)\n    public void InsertForeach()&#123;\n        List&lt;Emp&gt; list1 = TestController.list;\n        testMapper.testBatchInsert(list1);\n    &#125;\n&#125;\n\n\n\n\n\n\n\n\n\n失败，直接语法错误，看来values应该是有长度限制\n分页处理将代码改装成分页处理\njava@GetMapping(&quot;/foreach&quot;)\npublic void InsertForeach() throws InterruptedException &#123;\n    List&lt;Emp&gt; list1 = TestController.list;\n    long s = System.currentTimeMillis();\n    List&lt;List&lt;Emp&gt;&gt; partition = Lists.partition(list1, 400);\n    AtomicInteger startRow = new AtomicInteger(0);\n    while (true) &#123;\n        testMapper.testBatchInsert(partition.get(startRow.get()));\n        Integer offset = startRow.incrementAndGet();\n        // 最后一页\n        if (offset == partition.size()) &#123;\n            break;\n        &#125;\n    &#125;\n    System.out.println(System.currentTimeMillis() - s);\n&#125;\n\n\n\n\n\n\n\n\n耗时： 7.416\n多线程java@GetMapping(&quot;/foreach&quot;)\n    public void InsertForeach() throws InterruptedException &#123;\n        List&lt;Emp&gt; list1 = TestController.list;\n        long s = System.currentTimeMillis();\n        List&lt;List&lt;Emp&gt;&gt; partition = Lists.partition(list1, 400);\n        ThreadPoolExecutor threadPool = new ThreadPoolExecutor(20, 50,\n                4, TimeUnit.SECONDS, new ArrayBlockingQueue(200), new ThreadPoolExecutor.AbortPolicy());\n        CountDownLatch countDownLatch = new CountDownLatch(partition.size());\n        for (List&lt;Emp&gt; item : partition) &#123;\n            threadPool.execute(new Thread(new Runnable() &#123;\n                @Override\n                public void run() &#123;\n                    testMapper.testBatchInsert(item);\n                &#125;\n            &#125;));\n            countDownLatch.countDown();\n        &#125;\n        countDownLatch.await();\n        System.out.println(System.currentTimeMillis() - s);\n    &#125;\n\n\n\n\n\n\n\n\n耗时： 0.151 可能是测试方法不对\nJdbcTempjava@GetMapping(&quot;/foreach&quot;)\npublic void InsertForeach() throws InterruptedException &#123;\n    List&lt;Emp&gt; list1 = TestController.list;\n    long s = System.currentTimeMillis();\n    String sql = &quot;INSERT INTO emp (userName, pass, email) VALUES (?, ?, ?)&quot;;\n\n    jdbcTemplate.batchUpdate(sql, new BatchPreparedStatementSetter() &#123;\n        @Override\n        public void setValues(PreparedStatement ps, int i) throws SQLException &#123;\n            Emp emp = list1.get(i);\n            ps.setString(1, emp.getUserName());\n            ps.setString(2, emp.getPass());\n            ps.setString(3, emp.getEmail());\n        &#125;\n\n        @Override\n        public int getBatchSize() &#123;\n            return list1.size();\n        &#125;\n    &#125;);\n    System.out.println(System.currentTimeMillis() - s);\n&#125;\n\n\n\n\n\n\n\n\n耗时： 60.058 s \nsqlsessionjava@GetMapping(&quot;/foreach&quot;)\npublic void InsertForeach() throws InterruptedException &#123;\n    List&lt;Emp&gt; list1 = TestController.list;\n    List&lt;List&lt;Emp&gt;&gt; partition = Lists.partition(list1, 400);\n    long s = System.currentTimeMillis();\n    SqlSession sqlSession = sqlSessionFactory.openSession(ExecutorType.BATCH);\n    TestMapper sqlSessionMapper = sqlSession.getMapper(TestMapper.class);\n\n    long start = System.currentTimeMillis();\n\n    for (List&lt;Emp&gt; item : partition) &#123;\n        sqlSessionMapper.testBatchInsert(item);\n    &#125;\n    sqlSession.commit();\n    System.out.println(System.currentTimeMillis() - s);\n&#125;\n\n\n\n\n\n\n\n\n耗时： 6.544 s\n","slug":"backend/batchInsert","date":"2024-05-16T04:01:51.000Z","categories_index":"backend","tags_index":"mybatis","author_index":"panther"}]
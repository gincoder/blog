[{"id":"451ee4a035442e0633cafdb9c68dc333","title":"数据库优化第一步看懂explain","content":"explain常用字段\n\n\n\n\n\n\n\n\n\ntype ：访问的类型\nkey ：实际使用到的索引，如果为NULL，则没有使用索引\nref ：显示索引的哪一列被使用了，如果可能的话，是一个常数，哪些列或常量被用于查找索引列上的值\nrows ：根据表统计信息及索引选用情况，大致估算出找到所需的记录所需读取的行数\nExtra ：包含不适合在其它列中显示但十分重要的额外信息\n\n表数据1234567891011CREATE TABLE `user` (  `id` int NOT NULL AUTO_INCREMENT,  `name` varchar(255) CHARACTER SET armscii8 COLLATE armscii8_general_ci NOT NULL,  `account` varchar(255) CHARACTER SET armscii8 COLLATE armscii8_general_ci NOT NULL,  `pass` varchar(255) CHARACTER SET armscii8 COLLATE armscii8_general_ci NOT NULL,  `email` varchar(255) CHARACTER SET armscii8 COLLATE armscii8_general_ci NULL DEFAULT NULL,  PRIMARY KEY (`id`) USING BTREE) ENGINE = InnoDB CHARACTER SET = armscii8 COLLATE = armscii8_general_ci ROW_FORMAT = Dynamic;INSERT INTO `test`.`user` (`id`, `name`, `account`, `pass`, `email`) VALUES (1, &#x27;User1&#x27;, &#x27;user1&#x27;, &#x27;pass1&#x27;, &#x27;user1@example.com&#x27;);。。。\n\n常用分析1234567EXPLAIN select * from user where id = 14+----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+| id | select_type | table | partitions | type  | possible_keys | key     | key_len | ref   | rows | filtered | Extra |+----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+|  1 | SIMPLE      | user  | NULL       | const | PRIMARY       | PRIMARY | 4       | const |    1 |   100.00 | NULL  |+----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+1 row in set, 1 warning (0.00 sec)\n\n\n\n\n\n\n\n\n\n\nkey: PRIMARY 走的主键索引\nref： const 判断条件为常数匹配\nrows： 1  扫描数据条数\n范围匹配\n1234567EXPLAIN select * from user where id &gt;= 10 and id &lt;= 50;+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+-------------+| id | select_type | table | partitions | type  | possible_keys | key     | key_len | ref  | rows | filtered | Extra       |+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+-------------+|  1 | SIMPLE      | user  | NULL       | range | PRIMARY       | PRIMARY | 4       | NULL |   41 |   100.00 | Using where |+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+-------------+1 row in set, 1 warning (0.00 sec)\n\n\n\n\n\n\n\n\n\n\nkey: PRIMARY 主键索引\ntype： range 区间扫描\nrows: 41 扫描行数\nExtra： Using where 使用了where条件\n唯一约束\n123456789-- 将account字段设置为唯一约束ALTER TABLE user ADD CONSTRAINT UNIQUE(account);mysql&gt; EXPLAIN select * from user where account like &#x27;user%&#x27;；+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+-----------------------+| id | select_type | table | partitions | type  | possible_keys | key     | key_len | ref  | rows | filtered | Extra                 |+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+-----------------------+|  1 | SIMPLE      | user  | NULL       | range | account       | account | 257     | NULL |   51 |   100.00 | Using index condition |+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+-----------------------+1 row in set, 1 warning (0.00 sec)\n\n\n\n\n\n\n\n\n\n\nkey: account account字段索引\nrow: 51扫描行数\nExtra： Using index condition 使用索引判断\n1234567mysql&gt; EXPLAIN select * from user where account like &#x27;%user&#x27;;+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+|  1 | SIMPLE      | user  | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 1051 |    11.11 | Using where |+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+1 row in set, 1 warning (0.00 sec)\n\n\n\n\n\n\n\n\n\n\ntype: ALL 全表扫描 常见的索引失效\n1234567mysql&gt; EXPLAIN select * from user where id &gt;= 5 and id &lt;= 10 order by account;+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+-----------------------------+| id | select_type | table | partitions | type  | possible_keys | key     | key_len | ref  | rows | filtered | Extra                       |+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+-----------------------------+|  1 | SIMPLE      | user  | NULL       | range | PRIMARY       | PRIMARY | 4       | NULL |    6 |   100.00 | Using where; Using filesort |+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+-----------------------------+1 row in set, 1 warning (0.00 sec)\n\n\n\n\n\n\n\n\n\n\nExtra: Using where; Using filesort 使用条件判断，将判断出的数据进行文件排序（通常是以为没走索引所以才需要排序）\n123456789101112131415mysql&gt; explain select count(*) from user group by pass;+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-----------------+| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra           |+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-----------------+|  1 | SIMPLE      | user  | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 1051 |   100.00 | Using temporary |+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-----------------+1 row in set, 1 warning (0.00 sec)mysql&gt; explain select count(*) from user group by id;+----+-------------+-------+------------+-------+-----------------+---------+---------+------+------+----------+-------------+| id | select_type | table | partitions | type  | possible_keys   | key     | key_len | ref  | rows | filtered | Extra       |+----+-------------+-------+------------+-------+-----------------+---------+---------+------+------+----------+-------------+|  1 | SIMPLE      | user  | NULL       | index | PRIMARY,account | PRIMARY | 4       | NULL | 1051 |   100.00 | Using index |+----+-------------+-------+------------+-------+-----------------+---------+---------+------+------+----------+-------------+1 row in set, 1 warning (0.00 sec)\n\n\n\n\n\n\n\n\n\n\nExtra : Using temporary 表示Mysql创建了临时表来查询存储结果，通用在排序或分组发生\n1234567891011121314151617mysql&gt; explain select count(*) from user where id in( 100,123,112,121);+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+--------------------------+| id | select_type | table | partitions | type  | possible_keys | key     | key_len | ref  | rows | filtered | Extra                    |+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+--------------------------+|  1 | SIMPLE      | user  | NULL       | range | PRIMARY       | PRIMARY | 4       | NULL |    4 |   100.00 | Using where; Using index |+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+--------------------------+1 row in set, 1 warning (0.00 sec)mysql&gt; explain select count(*) from user where name in( user1,user3,user20,user40);ERROR 1054 (42S22): Unknown column &#x27;user1&#x27; in &#x27;where clause&#x27;mysql&gt; explain select count(*) from user where name in( &#x27;user1&#x27;,&#x27;user3&#x27;,&#x27;user20&#x27;,&#x27;user40&#x27;);+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+|  1 | SIMPLE      | user  | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 1051 |    40.00 | Using where |+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+1 row in set, 1 warning (0.00 sec)\n\n","slug":"arary/Explain","date":"2024-05-20T04:01:51.000Z","categories_index":"mysql","tags_index":"mysql","author_index":"panther"},{"id":"62f0380213af8188cf68f0ab26ba211b","title":"Redis实战之Redisson使用技巧详解","content":"摘要什么是 Redisson？来自于官网上的描述内容如下！\n\n\n\n\n\n\n\n\n\nRedisson 是一个在 Redis 的基础上实现的 Java 驻内存数据网格客户端（In-Memory Data Grid）。它不仅提供了一系列的 redis常用数据结构命令服务，还提供了许多分布式服务，例如分布式锁、分布式对象、分布式集合、分布式远程服务、分布式调度任务服务等等。\n相比于 Jedis、Lettuce 等基于 redis 命令封装的客户端，Redisson 提供的功能更加高端和抽象，逼格高！\n更多功能特性和开发文档说明，可用移步github进行获取，访问地址如下：\nredisson地址\n基本使用跟过去一样，首先创建一个 maven 项目，添加Redisson依赖包。\n12345&lt;dependency&gt;  &lt;groupId&gt;org.redisson&lt;/groupId&gt;  &lt;artifactId&gt;redisson&lt;/artifactId&gt;  &lt;version&gt;3.13.6&lt;/version&gt;&lt;/dependency&gt;\n\n单机环境下，简单样例如下！\n12345678910111213141516171819public static void main(String[] args) &#123;        Config config = new Config();        config.useSingleServer()                .setConnectionMinimumIdleSize(5) // 设置最下空闲数                .setConnectionPoolSize(10) // 设置连接池大小                .setIdleConnectionTimeout(3*1000) // 设置空闲连接超时时间 单位为毫秒                .setConnectTimeout(10*1000) // 设置连接超时时间 单位为毫秒                .setAddress(&quot;redis://127.0.0.1:6379&quot;)                .setDatabase(0);        //获取客户端        RedissonClient redissonClient = Redisson.create(config);        RBucket&lt;String&gt; selfBucket = redissonClient.getBucket(&quot;selfBucket&quot;);        selfBucket.set(&quot;hello&quot;,3, TimeUnit.SECONDS);        selfBucket.set(&quot;world&quot;);        //获取所有的key        redissonClient.getKeys().getKeys().forEach(key -&gt; System.out.println(key));        //关闭客户端        redissonClient.shutdown();    &#125;\n\n\n\n\n\n\n\n\n\n\nps：创建 RedissonClient 对象实例的方式多钟多样，可以直接通过在代码中设置 Redis 服务的相关参数创建，也可以通过加载 JSON 格式、 YAML 格式或者 Spring XML 配置文件来创建，详细的参数配置可用移步上文提到的 Redisson 开发文档。\nStringRedisson 支持通过RBucket对象来操作字符串数据结构，通过RBucket实例可以设置value或设置value和有效期，简单样例如下！\n\n简单字符串操作\n\n1234567891011//字符串操作RBucket&lt;String&gt; rBucket = redissonClient.getBucket(&quot;strKey&quot;);// 设置value和key的有效期rBucket.set(&quot;张三&quot;, 30, TimeUnit.SECONDS);//rBucket.getAndDelete();  获取strKey的值并删除strKey这个key//rBucket.compareAndSet(&quot;张三&quot;,&quot;李四&quot;); 和cas想同先比较后设置//rBucket.setIfExists(&quot;hello1&quot;); 存在值就设置// 通过key获取value//rBucket.isExists(); 判断当前桶是否有值// rBucket.delete(); 删除桶中数据System.out.println(redissonClient.getBucket(&quot;strKey&quot;).get());\n\n\n对象操作\n\nRedisson 支持将对象作为value存入redis，被存储的对象事先必须要实现序列化接口Serializable，否则会报错，简单样例如下！\n1234//字符串对象操作RBucket&lt;user&gt; rBucket = redissonClient.getBucket(&quot;strKey2&quot;);rBucket.set(new user().setId(1001).setName(&quot;stone&quot;));System.out.println(redissonClient.getBucket(&quot;strKey2&quot;).get());\n\nhashRedisson 支持通过RMap对象来操作哈希数据结构，简单样例如下！\n123456789RMap&lt;String, String&gt; rMap = redissonClient.getMap(&quot;mapkey&quot;);rMap.put(&quot;id&quot;, &quot;123&quot;);rMap.put(&quot;name&quot;, &quot;赵四&quot;);rMap.put(&quot;age&quot;, &quot;50&quot;);//rMap.putIfAbsent() 如果不存在设置//rMap.size() 大小// rMap.clear();清空集合rMap.expire(30, TimeUnit.SECONDS);System.out.println(redissonClient.getMap(&quot;mapkey&quot;).get(&quot;name&quot;));\n\nlist12345678910111213141516171819202122RList&lt;user&gt; rList = redissonClient.getList(&quot;listkey&quot;);user student1 = new user();student1.setId(1);student1.setName(&quot;张三&quot;);rList.add(student1);user student2 = new user();student2.setId(2);student2.setName(&quot;李四&quot;);rList.add(student2);//设置过期时间rList.expire(30, TimeUnit.SECONDS);// rList.subList(0,rList.size()).clear(); 获取子列表// rList.contains(student1);  判断是否存在student1// rList.indexOf(student2)   返回student2第一次出现的位置//  rList.lastIndexOf(student2)   返回student2最后一次出现的位置//rList.retainAll(Arrays.asList(student2)); 仅保留列表中存在的集合// rList.toArray() 转化成集合// 通过key获取valueSystem.out.println(redissonClient.getList(&quot;listkey&quot;));\n\nset1234567891011121314151617RSet&lt;user&gt; rSet = redissonClient.getSet(&quot;setkey&quot;);user student1 = new user();student1.setId(1L);student1.setName(&quot;张三&quot;);rSet.add(student1);user student2 = new user();student2.setId(2L);student2.setName(&quot;李四&quot;);rSet.add(student2);rSet.expire(30, TimeUnit.SECONDS);// rSet.contains(student1);判断集合中是否包含指定的元素。// rSet.iterator();返回集合的迭代器// rSet.retainAll(Arrays.asList(student1, student2));仅保留集合中包含在指定集合中的元素，移除其他元素。System.out.println(redissonClient.getSet(&quot;setkey&quot;));\n\nzsetRedisson 支持通过RSortedSet对象来操作有序集合数据结构，在使用对象来存储之前，实体对象必须先实现Comparable接口，并重写比较逻辑，否则会报错，简单样例如下！\n1234567891011121314RSortedSet&lt;user&gt; sortSetkey = redissonClient.get(&quot;sortSetkey&quot;);user student1 = new user();student1.setId(1);student1.setName(&quot;张三&quot;);sortSetkey.add(student1);user student2 = new user();student2.setId(2);student2.setName(&quot;李四&quot;);sortSetkey.add(student2);// sortSetkey.iterator() 返回集合的迭代器System.out.println(redissonClient.getSortedSet(&quot;sortSetkey&quot;));\n\n添加监听以String为例来对redis的一些操作进行监听\n布隆过滤器布隆过滤器（Bloom Filter）是 1970 年由布隆提出的。它实际上是一个很长的二进制向量和一系列随机映射函数。\n布隆过滤器可以用于检索一个元素是否在一个集合中。它的优点是空间效率和查询时间都比一般的算法要好的多，缺点是有一定的误识别率和删除困难。\nRedisson 支持通过RBloomFilter对象来操作布隆过滤器，简单样例如下！\n12345678910111213RBloomFilter rBloomFilter = redissonClient.getBloomFilter(&quot;seqId&quot;);// 初始化预期插入的数据量为10000和期望误差率为0.01rBloomFilter.tryInit(10000, 0.01);// 插入部分数据rBloomFilter.add(&quot;100&quot;);rBloomFilter.add(&quot;200&quot;);rBloomFilter.add(&quot;300&quot;);//设置过期时间rBloomFilter.expire(30, TimeUnit.SECONDS);// 判断是否存在System.out.println(rBloomFilter.contains(&quot;300&quot;));System.out.println(rBloomFilter.contains(&quot;200&quot;));System.out.println(rBloomFilter.contains(&quot;999&quot;));\n\n分布式自增idID 是数据的唯一标识，传统的做法是利用 UUID 和数据库的自增 ID。\n但由于 UUID 是无序的，不能附带一些其他信息，因此实际作用有限。\n随着业务的发展，数据量会越来越大，需要对数据进行分表，甚至分库。分表后每个表的数据会按自己的节奏来自增，这样会造成 ID 冲突，因此这时就需要一个单独的机制来负责生成唯一 ID，redis 原生支持生成全局唯一的 ID。\n简单样例如下！\n1234567final String lockKey = &quot;aaaa&quot;;//通过redis的自增获取序号RAtomicLong atomicLong = redissonClient.getAtomicLong(lockKey);//设置过期时间atomicLong.expire(30, TimeUnit.SECONDS);// 获取值System.out.println(atomicLong.incrementAndGet());\n\n分布式锁Redisson 最大的亮点，也是使用最多的功能，就是提供了强大的分布式锁实现，特点是：使用简单、安全！\n简单使用样例如下！\n1234567891011121314151617181920212223242526Config config = new Config();config.useSingleServer()        .setAddress(&quot;redis://127.0.0.1:6379&quot;)        .setPassword(&quot;123456&quot;)        .setDatabase(0);RedissonClient redissonClient = Redisson.create(config);//获取锁对象实例final String lockKey = &quot;abc&quot;;RLock rLock = redissonClient.getLock(lockKey);try &#123;    //尝试5秒内获取锁，如果获取到了，最长60秒自动释放    boolean res = rLock.tryLock(5L, 60L, TimeUnit.SECONDS);    if (res) &#123;        //成功获得锁，在这里处理业务        System.out.println(&quot;获取锁成功&quot;);    &#125;&#125; catch (Exception e) &#123;    System.out.println(&quot;获取锁失败，失败原因：&quot; + e.getMessage());&#125; finally &#123;    //无论如何, 最后都要解锁    rLock.unlock();&#125;//关闭客户端redissonClient.shutdown();\n\n以上是单机环境下的分布式锁实现逻辑，如果是集群环境下，应该如何处理呢？\nRedisson 提供RedissonRedLock操作类，也被称为红锁，实现原理简单的总结有以下几点：\n\n1.如果有多个 redis 集群的时候，当且仅当从大多数（N&#x2F;2+1，比如有3个 redis 节点，那么至少有2个节点）的 Redis 节点都取到锁，并且获取锁使用的总耗时小于锁失效时间时，锁才算获取成功\n2.如果获取失败，客户端会在所有的 Redis 实例上进行解锁操作\n3.集群环境下，redis 服务器直接不存在任何复制或者其他隐含的分布式协调机制，否则会存在实效的可能\n\nRedissonRedLock简单使用样例如下！\n1234567891011121314151617181920212223242526272829303132333435Config config1 = new Config();config1.useSingleServer().setAddress(&quot;redis://192.168.3.111:6379&quot;).setPassword(&quot;a123456&quot;).setDatabase(0);RedissonClient redissonClient1 = Redisson.create(config1);Config config2 = new Config();config2.useSingleServer().setAddress(&quot;redis://192.168.3.112:6379&quot;).setPassword(&quot;a123456&quot;).setDatabase(0);RedissonClient redissonClient2 = Redisson.create(config2);Config config3 = new Config();config3.useSingleServer().setAddress(&quot;redis://192.168.3.113:6379&quot;).setPassword(&quot;a123456&quot;).setDatabase(0);RedissonClient redissonClient3 = Redisson.create(config3);//获取多个 RLock 对象final String lockKey = &quot;abc&quot;;RLock lock1 = redissonClient1.getLock(lockKey);RLock lock2 = redissonClient2.getLock(lockKey);RLock lock3 = redissonClient3.getLock(lockKey);//根据多个 RLock 对象构建 RedissonRedLock （最核心的差别就在这里）RedissonRedLock redLock = new RedissonRedLock(lock1, lock2, lock3);try &#123;    //尝试5秒内获取锁，如果获取到了，最长60秒自动释放    boolean res = redLock.tryLock(5L, 60L, TimeUnit.SECONDS);    if (res) &#123;        //成功获得锁，在这里处理业务        System.out.println(&quot;获取锁成功&quot;);    &#125;&#125; catch (Exception e) &#123;    System.out.println(&quot;获取锁失败，失败原因：&quot; + e.getMessage());&#125; finally &#123;    //无论如何, 最后都要解锁    redLock.unlock();&#125;\n\n集群模式12345678Config config = new Config();config.useClusterServers()    .setScanInterval(2000) // 集群状态扫描间隔时间，单位是毫秒    //可以用&quot;rediss://&quot;来启用SSL连接    .addNodeAddress(&quot;redis://127.0.0.1:7000&quot;, &quot;redis://127.0.0.1:7001&quot;)    .addNodeAddress(&quot;redis://127.0.0.1:7002&quot;);RedissonClient redisson = Redisson.create(config);\n\n主从模式12345678Config config = new Config();config.useMasterSlaveServers()    //可以用&quot;rediss://&quot;来启用SSL连接    .setMasterAddress(&quot;redis://127.0.0.1:6379&quot;)    .addSlaveAddress(&quot;redis://127.0.0.1:6389&quot;, &quot;redis://127.0.0.1:6332&quot;, &quot;redis://127.0.0.1:6419&quot;)    .addSlaveAddress(&quot;redis://127.0.0.1:6399&quot;);RedissonClient redisson = Redisson.create(config);\n\n哨兵模式12345678Config config = new Config();config.useSentinelServers()    .setMasterName(&quot;mymaster&quot;)    //可以用&quot;rediss://&quot;来启用SSL连接    .addSentinelAddress(&quot;127.0.0.1:26389&quot;, &quot;127.0.0.1:26379&quot;)    .addSentinelAddress(&quot;127.0.0.1:26319&quot;);RedissonClient redisson = Redisson.create(config);\n\n","slug":"backend/redisson","date":"2024-05-16T04:01:51.000Z","categories_index":"backend","tags_index":"redis","author_index":"panther"},{"id":"568c8981e612913b5236501ef69a4929","title":"项目实战之批量插入性能分析","content":"\n\n\n\n\n\n\n\n\n不是专业测试，时间的参考价值不大，但是常见的批量插入方法应该能帮到你。\n模拟表12345678DROP TABLE IF EXISTS emp;CREATE TABLE emp (    id INT AUTO_INCREMENT PRIMARY KEY,    userName VARCHAR(255),    pass VARCHAR(255),    email VARCHAR(255));\n\n存储过程12345678910111213141516171819202122232425DELIMITER //CREATE PROCEDURE insert_emp_data()BEGIN    DECLARE i INT DEFAULT 1;    DECLARE batch_size INT DEFAULT 1000;    DECLARE total INT DEFAULT 100000;    DECLARE j INT;    WHILE i &lt;= total DO        START TRANSACTION;        SET j = 0;        WHILE j &lt; batch_size AND i &lt;= total DO            INSERT INTO emp (userName, pass, email)            VALUES (CONCAT(&#x27;user&#x27;, i), CONCAT(&#x27;pass&#x27;, i), CONCAT(&#x27;user&#x27;, i, &#x27;@example.com&#x27;));            SET i = i + 1;            SET j = j + 1;        END WHILE;        COMMIT;    END WHILE;END //DELIMITER ;CALL insert_emp_data();\n\n使用Mysql自带的存储过程进行10万条数据插入： \n\n\n\n\n\n\n\n\n\n耗时： 9.125 s\nMybatis-Foreach组装数据\n123456789101112131415161718192021222324@RestControllerpublic class TestController &#123;    private static List&lt;Emp&gt;  list;    @Resource    private TestMapper testMapper;    static &#123;        list = new ArrayList&lt;&gt;(100000);        for (int i = 0; i &lt; 100000; i++) &#123;            Emp emp = new Emp();            emp.setUserName(&quot;user&quot;+i);            emp.setPass(&quot;123&quot;+i);            emp.setEmail(&quot;example&quot;+i);            list.add(emp);        &#125;    &#125;    @GetMapping(&quot;/foreach&quot;)    public void InsertForeach()&#123;        List&lt;Emp&gt; list1 = TestController.list;        testMapper.testBatchInsert(list1);    &#125;&#125;\n\n\n\n\n\n\n\n\n\n\n失败，直接语法错误，看来values应该是有长度限制\n分页处理将代码改装成分页处理\n12345678910111213141516@GetMapping(&quot;/foreach&quot;)public void InsertForeach() throws InterruptedException &#123;    List&lt;Emp&gt; list1 = TestController.list;    long s = System.currentTimeMillis();    List&lt;List&lt;Emp&gt;&gt; partition = Lists.partition(list1, 400);    AtomicInteger startRow = new AtomicInteger(0);    while (true) &#123;        testMapper.testBatchInsert(partition.get(startRow.get()));        Integer offset = startRow.incrementAndGet();        // 最后一页        if (offset == partition.size()) &#123;            break;        &#125;    &#125;    System.out.println(System.currentTimeMillis() - s);&#125;\n\n\n\n\n\n\n\n\n\n\n耗时： 7.416\n多线程1234567891011121314151617181920@GetMapping(&quot;/foreach&quot;)    public void InsertForeach() throws InterruptedException &#123;        List&lt;Emp&gt; list1 = TestController.list;        long s = System.currentTimeMillis();        List&lt;List&lt;Emp&gt;&gt; partition = Lists.partition(list1, 400);        ThreadPoolExecutor threadPool = new ThreadPoolExecutor(20, 50,                4, TimeUnit.SECONDS, new ArrayBlockingQueue(200), new ThreadPoolExecutor.AbortPolicy());        CountDownLatch countDownLatch = new CountDownLatch(partition.size());        for (List&lt;Emp&gt; item : partition) &#123;            threadPool.execute(new Thread(new Runnable() &#123;                @Override                public void run() &#123;                    testMapper.testBatchInsert(item);                &#125;            &#125;));            countDownLatch.countDown();        &#125;        countDownLatch.await();        System.out.println(System.currentTimeMillis() - s);    &#125;\n\n\n\n\n\n\n\n\n\n\n耗时： 0.151 可能是测试方法不对\nJdbcTemp12345678910111213141516171819202122@GetMapping(&quot;/foreach&quot;)public void InsertForeach() throws InterruptedException &#123;    List&lt;Emp&gt; list1 = TestController.list;    long s = System.currentTimeMillis();    String sql = &quot;INSERT INTO emp (userName, pass, email) VALUES (?, ?, ?)&quot;;    jdbcTemplate.batchUpdate(sql, new BatchPreparedStatementSetter() &#123;        @Override        public void setValues(PreparedStatement ps, int i) throws SQLException &#123;            Emp emp = list1.get(i);            ps.setString(1, emp.getUserName());            ps.setString(2, emp.getPass());            ps.setString(3, emp.getEmail());        &#125;        @Override        public int getBatchSize() &#123;            return list1.size();        &#125;    &#125;);    System.out.println(System.currentTimeMillis() - s);&#125;\n\n\n\n\n\n\n\n\n\n\n耗时： 60.058 s \nsqlsession12345678910111213141516@GetMapping(&quot;/foreach&quot;)public void InsertForeach() throws InterruptedException &#123;    List&lt;Emp&gt; list1 = TestController.list;    List&lt;List&lt;Emp&gt;&gt; partition = Lists.partition(list1, 400);    long s = System.currentTimeMillis();    SqlSession sqlSession = sqlSessionFactory.openSession(ExecutorType.BATCH);    TestMapper sqlSessionMapper = sqlSession.getMapper(TestMapper.class);    long start = System.currentTimeMillis();    for (List&lt;Emp&gt; item : partition) &#123;        sqlSessionMapper.testBatchInsert(item);    &#125;    sqlSession.commit();    System.out.println(System.currentTimeMillis() - s);&#125;\n\n\n\n\n\n\n\n\n\n\n耗时： 6.544 s\n","slug":"backend/batchInsert","date":"2024-05-16T04:01:51.000Z","categories_index":"backend","tags_index":"mybatis","author_index":"panther"}]